{"ast":null,"code":"import _orderBy from \"lodash/orderBy\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport { interpolate } from \"victory-vendor/d3-interpolate\";\nexport var isInterpolatable = function (obj) {\n  // d3 turns null into 0 and undefined into NaN, which we don't want.\n  if (obj !== null) {\n    switch (typeof obj) {\n      case \"undefined\":\n        return false;\n      case \"number\":\n        // The standard `isNaN` is fine in this case since we already know the\n        // type is number.\n        return !isNaN(obj) && obj !== Number.POSITIVE_INFINITY && obj !== Number.NEGATIVE_INFINITY;\n      case \"string\":\n        // d3 might not *actually* be able to interpolate the string, but it\n        // won't cause any issues to let it try.\n        return true;\n      case \"boolean\":\n        // d3 turns Booleans into integers, which we don't want. Sure, we could\n        // interpolate from 0 -> 1, but we'd be sending a non-Boolean to\n        // something expecting a Boolean.\n        return false;\n      case \"object\":\n        // Don't try to interpolate class instances (except Date or Array).\n        return obj instanceof Date || Array.isArray(obj) || _isPlainObject(obj);\n      case \"function\":\n        // Careful! There may be extra properties on function objects that the\n        // component expects to access - for instance, it may be a `d3.scale()`\n        // function, which has its own methods attached. We don't know if the\n        // component is only going to call the function (in which case it's\n        // safely interpolatable) or if it's going to access special properties\n        // (in which case our function generated from `interpolateFunction` will\n        // most likely cause an error). We could check for enumerable properties\n        // on the function object here to see if it's a \"plain\" function, but\n        // let's just require that components prevent such function props from\n        // being animated in the first place.\n        return true;\n    }\n  }\n  return false;\n};\n/**\n * Interpolate immediately to the end value at the given step `when`.\n * Some nicer default behavior might be to jump at the halfway point or return\n * `a` if `t` is 0 (instead of always returning `b`). But d3's default\n * interpolator does not do these things:\n *\n *   d3.interpolate('aaa', 'bbb')(0) === 'bbb'\n *\n * ...and things might get wonky if we don't replicate that behavior.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @param {Number} when - Step value (0 to 1) at which to jump to `b`.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateImmediate = function (a, b) {\n  var when = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return function (t) {\n    return t < when ? a : b;\n  };\n};\n/**\n * Interpolate to or from a function. The interpolated value will be a function\n * that calls `a` (if it's a function) and `b` (if it's a function) and calls\n * `d3.interpolate` on the resulting values. Note that our function won't\n * necessarily be called (that's up to the component this eventually gets\n * passed to) - but if it does get called, it will return an appropriately\n * interpolated value.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateFunction = function (a, b) {\n  return function (t) {\n    if (t >= 1) {\n      return b;\n    }\n    return function () {\n      /* eslint-disable no-invalid-this, prefer-rest-params */\n      var aval = typeof a === \"function\" ? a.apply(this, arguments) : a;\n      var bval = typeof b === \"function\" ? b.apply(this, arguments) : b;\n      return interpolate(aval, bval)(t);\n    };\n  };\n};\n/**\n * Interpolate to or from an object. This method is a modification of the object interpolator in\n * d3-interpolate https://github.com/d3/d3-interpolate/blob/master/src/object.js. This interpolator\n * differs in that it uses our custom interpolators when interpolating the value of each property in\n * an object. This allows the correct interpolation of nested objects, including styles\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateObject = function (a, b) {\n  var interpolateTypes = function (x, y) {\n    if (x === y || !isInterpolatable(x) || !isInterpolatable(y)) {\n      return interpolateImmediate(x, y);\n    }\n    if (typeof x === \"function\" || typeof y === \"function\") {\n      return interpolateFunction(x, y);\n    }\n    if (typeof x === \"object\" && _isPlainObject(x) || typeof y === \"object\" && _isPlainObject(y)) {\n      return interpolateObject(x, y);\n    }\n    return interpolate(x, y);\n  }; // When the value is an array, attempt to sort by \"key\" so that animating nodes may be identified\n  // based on \"key\" instead of index\n\n  var keyData = function (val) {\n    return Array.isArray(val) ? _orderBy(val, \"key\") : val;\n  };\n  var i = {};\n  var c = {};\n  var k;\n  if (a === null || typeof a !== \"object\") {\n    a = {};\n  }\n  if (b === null || typeof b !== \"object\") {\n    b = {};\n  }\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateTypes(keyData(a[k]), keyData(b[k]));\n    } else {\n      c[k] = b[k];\n    }\n  }\n  return function (t) {\n    for (k in i) {\n      c[k] = i[k](t);\n    }\n    return c;\n  };\n};\nexport var interpolateString = function (a, b) {\n  var format = function (val) {\n    return typeof val === \"string\" ? val.replace(/,/g, \"\") : val;\n  };\n  return interpolate(format(a), format(b));\n};\n/**\n * By default, the list of interpolators used by `d3.interpolate` has a few\n * downsides:\n *\n * - `null` values get turned into 0.\n * - `undefined`, `function`, and some other value types get turned into NaN.\n * - Boolean types get turned into numbers, which probably will be meaningless\n *   to whatever is consuming them.\n * - It tries to interpolate between identical start and end values, doing\n *   unnecessary calculations that sometimes result in floating point rounding\n *   errors.\n *\n * If only the default interpolators are used, `VictoryAnimation` will happily\n * pass down NaN (and other bad) values as props to the wrapped component.\n * The component will then either use the incorrect values or complain that it\n * was passed props of the incorrect type. This custom interpolator is added\n * using the `d3.interpolators` API, and prevents such cases from happening\n * for most values.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function|undefined} An interpolation function, if necessary.\n */\n\nexport var victoryInterpolator = function (a, b) {\n  // If the values are strictly equal, or either value is not interpolatable,\n  // just use either the start value `a` or end value `b` at every step, as\n  // there is no reasonable in-between value.\n  if (a === b || !isInterpolatable(a) || !isInterpolatable(b)) {\n    return interpolateImmediate(a, b);\n  }\n  if (typeof a === \"function\" || typeof b === \"function\") {\n    return interpolateFunction(a, b);\n  }\n  if (_isPlainObject(a) || _isPlainObject(b)) {\n    // @ts-expect-error These generics are tough, but they work :)\n    return interpolateObject(a, b);\n  }\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return interpolateString(a, b);\n  } // @ts-expect-error These generics are tough, but they work :)\n\n  return interpolate(a, b);\n};","map":{"version":3,"names":["_orderBy","_isPlainObject","interpolate","isInterpolatable","obj","isNaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","Date","Array","isArray","interpolateImmediate","a","b","when","arguments","length","undefined","t","interpolateFunction","aval","apply","bval","interpolateObject","interpolateTypes","x","y","keyData","val","i","c","k","interpolateString","format","replace","victoryInterpolator"],"sources":["C:/Users/Kevin/Desktop/Website/money-support/node_modules/victory-core/es/victory-animation/util.js"],"sourcesContent":["import _orderBy from \"lodash/orderBy\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport { interpolate } from \"victory-vendor/d3-interpolate\";\nexport var isInterpolatable = function (obj) {\n  // d3 turns null into 0 and undefined into NaN, which we don't want.\n  if (obj !== null) {\n    switch (typeof obj) {\n      case \"undefined\":\n        return false;\n\n      case \"number\":\n        // The standard `isNaN` is fine in this case since we already know the\n        // type is number.\n        return !isNaN(obj) && obj !== Number.POSITIVE_INFINITY && obj !== Number.NEGATIVE_INFINITY;\n\n      case \"string\":\n        // d3 might not *actually* be able to interpolate the string, but it\n        // won't cause any issues to let it try.\n        return true;\n\n      case \"boolean\":\n        // d3 turns Booleans into integers, which we don't want. Sure, we could\n        // interpolate from 0 -> 1, but we'd be sending a non-Boolean to\n        // something expecting a Boolean.\n        return false;\n\n      case \"object\":\n        // Don't try to interpolate class instances (except Date or Array).\n        return obj instanceof Date || Array.isArray(obj) || _isPlainObject(obj);\n\n      case \"function\":\n        // Careful! There may be extra properties on function objects that the\n        // component expects to access - for instance, it may be a `d3.scale()`\n        // function, which has its own methods attached. We don't know if the\n        // component is only going to call the function (in which case it's\n        // safely interpolatable) or if it's going to access special properties\n        // (in which case our function generated from `interpolateFunction` will\n        // most likely cause an error). We could check for enumerable properties\n        // on the function object here to see if it's a \"plain\" function, but\n        // let's just require that components prevent such function props from\n        // being animated in the first place.\n        return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Interpolate immediately to the end value at the given step `when`.\n * Some nicer default behavior might be to jump at the halfway point or return\n * `a` if `t` is 0 (instead of always returning `b`). But d3's default\n * interpolator does not do these things:\n *\n *   d3.interpolate('aaa', 'bbb')(0) === 'bbb'\n *\n * ...and things might get wonky if we don't replicate that behavior.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @param {Number} when - Step value (0 to 1) at which to jump to `b`.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateImmediate = function (a, b) {\n  var when = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return function (t) {\n    return t < when ? a : b;\n  };\n};\n/**\n * Interpolate to or from a function. The interpolated value will be a function\n * that calls `a` (if it's a function) and `b` (if it's a function) and calls\n * `d3.interpolate` on the resulting values. Note that our function won't\n * necessarily be called (that's up to the component this eventually gets\n * passed to) - but if it does get called, it will return an appropriately\n * interpolated value.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateFunction = function (a, b) {\n  return function (t) {\n    if (t >= 1) {\n      return b;\n    }\n\n    return function () {\n      /* eslint-disable no-invalid-this, prefer-rest-params */\n      var aval = typeof a === \"function\" ? a.apply(this, arguments) : a;\n      var bval = typeof b === \"function\" ? b.apply(this, arguments) : b;\n      return interpolate(aval, bval)(t);\n    };\n  };\n};\n/**\n * Interpolate to or from an object. This method is a modification of the object interpolator in\n * d3-interpolate https://github.com/d3/d3-interpolate/blob/master/src/object.js. This interpolator\n * differs in that it uses our custom interpolators when interpolating the value of each property in\n * an object. This allows the correct interpolation of nested objects, including styles\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\n\nexport var interpolateObject = function (a, b) {\n  var interpolateTypes = function (x, y) {\n    if (x === y || !isInterpolatable(x) || !isInterpolatable(y)) {\n      return interpolateImmediate(x, y);\n    }\n\n    if (typeof x === \"function\" || typeof y === \"function\") {\n      return interpolateFunction(x, y);\n    }\n\n    if (typeof x === \"object\" && _isPlainObject(x) || typeof y === \"object\" && _isPlainObject(y)) {\n      return interpolateObject(x, y);\n    }\n\n    return interpolate(x, y);\n  }; // When the value is an array, attempt to sort by \"key\" so that animating nodes may be identified\n  // based on \"key\" instead of index\n\n\n  var keyData = function (val) {\n    return Array.isArray(val) ? _orderBy(val, \"key\") : val;\n  };\n\n  var i = {};\n  var c = {};\n  var k;\n\n  if (a === null || typeof a !== \"object\") {\n    a = {};\n  }\n\n  if (b === null || typeof b !== \"object\") {\n    b = {};\n  }\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateTypes(keyData(a[k]), keyData(b[k]));\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function (t) {\n    for (k in i) {\n      c[k] = i[k](t);\n    }\n\n    return c;\n  };\n};\nexport var interpolateString = function (a, b) {\n  var format = function (val) {\n    return typeof val === \"string\" ? val.replace(/,/g, \"\") : val;\n  };\n\n  return interpolate(format(a), format(b));\n};\n/**\n * By default, the list of interpolators used by `d3.interpolate` has a few\n * downsides:\n *\n * - `null` values get turned into 0.\n * - `undefined`, `function`, and some other value types get turned into NaN.\n * - Boolean types get turned into numbers, which probably will be meaningless\n *   to whatever is consuming them.\n * - It tries to interpolate between identical start and end values, doing\n *   unnecessary calculations that sometimes result in floating point rounding\n *   errors.\n *\n * If only the default interpolators are used, `VictoryAnimation` will happily\n * pass down NaN (and other bad) values as props to the wrapped component.\n * The component will then either use the incorrect values or complain that it\n * was passed props of the incorrect type. This custom interpolator is added\n * using the `d3.interpolators` API, and prevents such cases from happening\n * for most values.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function|undefined} An interpolation function, if necessary.\n */\n\nexport var victoryInterpolator = function (a, b) {\n  // If the values are strictly equal, or either value is not interpolatable,\n  // just use either the start value `a` or end value `b` at every step, as\n  // there is no reasonable in-between value.\n  if (a === b || !isInterpolatable(a) || !isInterpolatable(b)) {\n    return interpolateImmediate(a, b);\n  }\n\n  if (typeof a === \"function\" || typeof b === \"function\") {\n    return interpolateFunction(a, b);\n  }\n\n  if (_isPlainObject(a) || _isPlainObject(b)) {\n    // @ts-expect-error These generics are tough, but they work :)\n    return interpolateObject(a, b);\n  }\n\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return interpolateString(a, b);\n  } // @ts-expect-error These generics are tough, but they work :)\n\n\n  return interpolate(a, b);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}